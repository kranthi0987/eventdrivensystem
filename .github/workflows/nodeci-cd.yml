name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Add permissions block
permissions:
  contents: read
  packages: read
  id-token: write
  checks: write
  deployments: write
  actions: write  # Required for uploading/downloading artifacts

env:
  AWS_REGION: ap-south-1
  TERRAFORM_WORKING_DIR: terraform/
  ZIP_FILE_NAME: deploy.zip
  INSTANCE_TYPE: "t3.micro"
  FRONTEND_APP_NAME: event-monitor
  S3_BUCKET_NAME: event-monitor-frontend
  TERRAFORM_STATE_BUCKET: eventdrivensystem-terraform-state
  ARTIFACT_RETENTION_DAYS: 5
  APP_PORT: 8081
  EC2_USER: ec2-user
  EC2_KEY_NAME: eventdrivensystem-key

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"

      - name: Initialize Terraform
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: |
          terraform init

      - name: Apply Terraform Configuration
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: |
          terraform apply -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=eventdrivensystem" \
            -var="instance_type=t3.micro" \
            -var="app_port=${{ env.APP_PORT }}"

      - name: Download EC2 key from S3
        run: |
          # Get bucket and key names from Terraform output
          BUCKET_NAME=$(terraform output -state=${{ env.TERRAFORM_WORKING_DIR }}/terraform.tfstate -raw key_bucket_name)
          KEY_NAME=$(terraform output -state=${{ env.TERRAFORM_WORKING_DIR }}/terraform.tfstate -raw key_object_name)
          
          # Create .ssh directory if it doesn't exist
          mkdir -p ~/.ssh
          
          # Download key from S3
          aws s3 cp "s3://${BUCKET_NAME}/${KEY_NAME}" ~/.ssh/ec2-key.pem
          
          # Set proper permissions
          chmod 400 ~/.ssh/ec2-key.pem

      - name: Deploy application
        run: |
          # Get EC2 instance IP
          EC2_IP=$(terraform output -state=${{ env.TERRAFORM_WORKING_DIR }}/terraform.tfstate -raw instance_public_ip)
          
          echo "EC2 Instance IP: ${EC2_IP}"
          
          # Wait for instance to be ready (increased wait time)
          echo "Waiting for instance to be ready..."
          sleep 120  # Increased from 60 to 120 seconds
          
          # Function to check SSH connection with detailed diagnostics
          check_ssh() {
            echo "Attempting SSH connection to ${EC2_IP}..."
            ssh -v -o StrictHostKeyChecking=no \
              -o ConnectTimeout=30 \
              -o ServerAliveInterval=15 \
              -o ServerAliveCountMax=3 \
              -i ~/.ssh/ec2-key.pem \
              ${EC2_USER}@${EC2_IP} \
              "echo 'SSH connection successful'"
          }
          
          # Function to check security group
          check_security_group() {
            echo "Checking security group configuration..."
            aws ec2 describe-security-groups \
              --filters "Name=ip-permission.to-port,Values=22" \
              --query "SecurityGroups[*].{GroupId:GroupId,GroupName:GroupName}" \
              --output table
          }
          
          # Check security group first
          check_security_group
          
          # Retry SSH connection with increased attempts
          MAX_RETRIES=10  # Increased from 5 to 10
          RETRY_COUNT=0
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if check_ssh; then
              echo "SSH connection established"
              break
            else
              echo "SSH connection attempt $((RETRY_COUNT + 1)) failed. Retrying in 60 seconds..."
              sleep 60  # Increased from 30 to 60 seconds
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "Failed to establish SSH connection after $MAX_RETRIES attempts"
            echo "Checking instance status..."
            aws ec2 describe-instance-status --instance-ids $(terraform output -state=${{ env.TERRAFORM_WORKING_DIR }}/terraform.tfstate -raw instance_id) --output table
            exit 1
          fi
          
          # Create deployment script
          cat > deploy.sh << 'EOF'
          #!/bin/bash
          set -e
          
          # Function to run npm with timeout
          run_npm_with_timeout() {
            local command=$1
            local timeout=300  # 5 minutes timeout
            local start_time=$(date +%s)
            
            echo "Running npm command: $command"
            timeout $timeout npm $command || {
              local end_time=$(date +%s)
              local duration=$((end_time - start_time))
              echo "npm command timed out after $duration seconds"
              return 1
            }
          }
          
          # Function to retry npm command
          retry_npm() {
            local command=$1
            local max_retries=3
            local retry_count=0
            
            while [ $retry_count -lt $max_retries ]; do
              echo "Attempting npm command (attempt $((retry_count + 1)) of $max_retries)..."
              if run_npm_with_timeout "$command"; then
                return 0
              else
                echo "npm command failed. Retrying in 30 seconds..."
                sleep 30
                retry_count=$((retry_count + 1))
              fi
            done
            
            echo "npm command failed after $max_retries attempts"
            return 1
          }
          
          # Update system
          sudo yum update -y
          
          # Install Git
          sudo yum install -y git
          
          # Install Node.js 20.x and npm
          curl -fsSL https://rpm.nodesource.com/setup_20.x | sudo bash -
          sudo yum install -y nodejs
          
          # Verify Node.js and npm versions
          node --version
          npm --version
          
          # Install PM2
          sudo npm install -g pm2
          
          # Create app directory
          sudo mkdir -p /var/www/app
          sudo chown -R ec2-user:ec2-user /var/www/app
          
          # Clone repository
          cd /var/www/app
          git clone $GITHUB_REPOSITORY_URL .
          git checkout $GITHUB_REF_NAME
          
          # Clean npm cache
          echo "Cleaning npm cache..."
          npm cache clean --force
          
          # Install dependencies with retry
          echo "Installing dependencies..."
          retry_npm "install --ignore-scripts"
          
          # Run linting with retry
          echo "Running linting..."
          retry_npm "run lint"
          
          # Build application with retry
          echo "Building application..."
          retry_npm "run build"
          
          # Configure Nginx
          sudo tee /etc/nginx/conf.d/app.conf << 'NGINX_EOF'
          server {
              listen 80;
              server_name _;
          
              location / {
                  proxy_pass http://localhost:$APP_PORT;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host $host;
                  proxy_cache_bypass $http_upgrade;
              }
          }
          NGINX_EOF
          
          # Start application with PM2
          pm2 start npm --name "app" -- start
          pm2 save
          pm2 startup
          
          # Restart Nginx
          sudo systemctl restart nginx
          EOF
          
          # Make script executable
          chmod +x deploy.sh
          
          # Function to copy and run deployment script with retry
          deploy_with_retry() {
            local retry_count=0
            local max_retries=5  # Increased from 3 to 5
            
            while [ $retry_count -lt $max_retries ]; do
              echo "Attempting to copy deployment script (attempt $((retry_count + 1)) of $max_retries)..."
              if scp -v -o StrictHostKeyChecking=no \
                -o ConnectTimeout=30 \
                -o ServerAliveInterval=15 \
                -o ServerAliveCountMax=3 \
                -i ~/.ssh/ec2-key.pem \
                deploy.sh ${EC2_USER}@${EC2_IP}:/tmp/; then
                echo "Successfully copied deployment script"
                break
              else
                echo "Failed to copy deployment script. Retrying in 60 seconds..."
                sleep 60  # Increased from 30 to 60 seconds
                retry_count=$((retry_count + 1))
              fi
            done
            
            if [ $retry_count -eq $max_retries ]; then
              echo "Failed to copy deployment script after $max_retries attempts"
              exit 1
            fi
            
            # Run deployment script with retry
            retry_count=0
            while [ $retry_count -lt $max_retries ]; do
              echo "Attempting to run deployment script (attempt $((retry_count + 1)) of $max_retries)..."
              if ssh -v -o StrictHostKeyChecking=no \
                -o ConnectTimeout=30 \
                -o ServerAliveInterval=15 \
                -o ServerAliveCountMax=3 \
                -i ~/.ssh/ec2-key.pem \
                ${EC2_USER}@${EC2_IP} \
                "GITHUB_REPOSITORY_URL='$GITHUB_SERVER_URL/$GITHUB_REPOSITORY.git' GITHUB_REF_NAME='$GITHUB_REF_NAME' APP_PORT='${{ env.APP_PORT }}' bash /tmp/deploy.sh"; then
                echo "Deployment completed successfully"
                break
              else
                echo "Deployment failed. Retrying in 60 seconds..."
                sleep 60  # Increased from 30 to 60 seconds
                retry_count=$((retry_count + 1))
              fi
            done
            
            if [ $retry_count -eq $max_retries ]; then
              echo "Deployment failed after $max_retries attempts"
              exit 1
            fi
          }
          
          # Execute deployment with retry
          deploy_with_retry

      - name: Verify deployment
        run: |
          # Get EC2 instance IP
          EC2_IP=$(terraform output -state=${{ env.TERRAFORM_WORKING_DIR }}/terraform.tfstate -raw instance_public_ip)
          
          echo "Waiting for application to be ready..."
          sleep 30
          
          # Try multiple times to connect
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -s -f "http://${EC2_IP}"; then
              echo "Application is responding successfully!"
              exit 0
            else
              echo "Attempt $((RETRY_COUNT + 1)) failed. Waiting before retry..."
              sleep 10
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done
          
          echo "Application is not responding after $MAX_RETRIES attempts"
          exit 1