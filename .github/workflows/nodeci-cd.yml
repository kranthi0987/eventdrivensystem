name: CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Add permissions block
permissions:
  contents: read
  packages: read
  id-token: write
  checks: write
  deployments: write
  actions: write  # Required for uploading/downloading artifacts

env:
  AWS_REGION: ap-south-1
  TERRAFORM_WORKING_DIR: terraform/
  ZIP_FILE_NAME: deploy.zip
  INSTANCE_TYPE: "t3.micro"
  FRONTEND_APP_NAME: event-monitor
  S3_BUCKET_NAME: event-monitor-frontend
  TERRAFORM_STATE_BUCKET: eventdrivensystem-terraform-state
  ARTIFACT_RETENTION_DAYS: 5
  APP_PORT: 8081
  EC2_USER: ec2-user

jobs:
  build-backend:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run linting
        run: npm run lint

      - name: Build application
        run: npm run build --if-present

      - name: Run tests
        run: npm test

      - name: Create deployment scripts
        run: |
          mkdir -p scripts
          
          # Create setup script
          cat > scripts/setup.sh << 'EOF'
          #!/bin/bash
          set -e  # Exit on any error
          
          echo "Starting system setup..."
          
          # Update system
          sudo yum update -y
          
          # Install Node.js 18
          echo "Installing Node.js..."
          curl -fsSL https://rpm.nodesource.com/setup_18.x | sudo bash -
          sudo yum install -y nodejs
          
          # Verify Node.js installation
          echo "Verifying Node.js installation..."
          node --version
          npm --version
          
          # Install PM2 globally and ensure it's in PATH
          echo "Installing PM2..."
          sudo npm install -g pm2@latest
          
          # Ensure binary paths are available
          sudo ln -sf /usr/local/bin/pm2 /usr/bin/pm2
          sudo ln -sf /usr/local/bin/node /usr/bin/node
          sudo ln -sf /usr/local/bin/npm /usr/bin/npm
          
          # Create app directory with proper permissions
          echo "Setting up application directory..."
          sudo mkdir -p /var/www
          sudo mkdir -p /var/www/app
          sudo chown -R ec2-user:ec2-user /var/www
          sudo chmod 755 /var/www
          sudo chown -R ec2-user:ec2-user /var/www/app
          sudo chmod 755 /var/www/app
          
          # Install Nginx
          echo "Installing and configuring Nginx..."
          sudo yum install -y nginx
          
          # Configure Nginx
          sudo tee /etc/nginx/conf.d/app.conf << 'NGINX_EOF'
          server {
              listen 80;
              server_name _;
          
              location / {
                  proxy_pass http://localhost:8081;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection 'upgrade';
                  proxy_set_header Host $host;
                  proxy_cache_bypass $http_upgrade;
              }
          }
          NGINX_EOF
          
          # Remove default nginx config
          sudo rm -f /etc/nginx/conf.d/default.conf
          
          # Start Nginx
          sudo systemctl enable nginx
          sudo systemctl start nginx
          
          echo "Setup completed successfully!"
          EOF
          
          # Create deployment script
          cat > scripts/deploy.sh << 'EOF'
          #!/bin/bash
          set -e  # Exit on any error
          
          echo "Starting deployment..."
          
          # Source the path to ensure we have access to npm
          source ~/.bashrc
          export PATH=$PATH:/usr/local/bin:/usr/bin
          
          APP_DIR="/var/www/app"
          
          # Ensure directories exist with proper permissions
          echo "Ensuring directory structure..."
          sudo mkdir -p ${APP_DIR}
          sudo chown -R ec2-user:ec2-user ${APP_DIR}
          sudo chmod 755 ${APP_DIR}
          
          echo "Stopping existing application..."
          if command -v pm2 &> /dev/null; then
            pm2 stop app || true
            pm2 delete app || true
          fi
          
          echo "Cleaning up old files..."
          rm -rf ${APP_DIR}/*
          
          echo "Extracting new files..."
          cd /tmp
          unzip -o deploy.zip -d ${APP_DIR}/
          
          echo "Setting permissions..."
          sudo chown -R ec2-user:ec2-user ${APP_DIR}
          sudo chmod -R 755 ${APP_DIR}
          
          echo "Installing dependencies..."
          cd ${APP_DIR}
          npm ci --production
          
          echo "Starting application with PM2..."
          pm2 start npm --name "app" -- start
          pm2 save
          
          echo "Setting up PM2 startup script..."
          sudo env PATH=$PATH pm2 startup systemd -u ec2-user --hp /home/ec2-user
          
          echo "Checking application status..."
          sleep 10  # Wait for the application to start
          
          if pm2 show app | grep -q "online"; then
            echo "Application deployed successfully!"
            exit 0
          else
            echo "Deployment failed - application is not running"
            pm2 logs app
            exit 1
          fi
          EOF
          
          chmod +x scripts/setup.sh scripts/deploy.sh

      - name: Create default success page
        run: |
          mkdir -p public
          cat > public/index.html << 'EOF'
          <!DOCTYPE html>
          <html>
            <head>
              <title>Deployment Success</title>
              <style>
                body {
                  font-family: Arial, sans-serif;
                  margin: 40px;
                  line-height: 1.6;
                  text-align: center;
                }
                .container {
                  max-width: 800px;
                  margin: 0 auto;
                  padding: 20px;
                  border: 1px solid #ddd;
                  border-radius: 5px;
                }
                .success {
                  color: #28a745;
                }
              </style>
            </head>
            <body>
              <div class="container">
                <h1 class="success">âœ… Deployment Successful!</h1>
                <p>Your application has been successfully deployed.</p>
                <p>Timestamp: $(date)</p>
                <p>Region: ${AWS_REGION}</p>
              </div>
            </body>
          </html>
          EOF

      - name: Zip deployment package
        run: |
          zip -r $ZIP_FILE_NAME . \
            -x "*.git*" \
            -x "node_modules/*" \
            -x ".github/*" \
            -x ".idea/*" \
            -x "*.DS_Store" \
            -x "apps/$FRONTEND_APP_NAME/*" \
            -x "terraform/*" \
            -i "public/*" \
            -i "scripts/*"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: deployment-package
          path: |
            ${{ env.ZIP_FILE_NAME }}
            scripts/
          retention-days: ${{ env.ARTIFACT_RETENTION_DAYS }}

  build-frontend:
    needs: build-backend
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '22'
          cache: 'npm'

      - name: Install dependencies
        run: |
          cd apps/event-monitor
          npm ci

      - name: Build frontend
        run: |
          cd apps/event-monitor
          npm run build

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Create S3 Bucket if not exists
        run: |
            if ! aws s3 ls "s3://$S3_BUCKET_NAME" 2>&1 | grep -q 'NoSuchBucket'; then
              echo "Syncing files to S3 bucket $S3_BUCKET_NAME"
              aws s3 sync apps/event-monitor/dist s3://$S3_BUCKET_NAME --delete
              aws s3 cp apps/event-monitor/dist/index.html s3://$S3_BUCKET_NAME/index.html --cache-control "no-cache,no-store,must-revalidate"
              echo "Files synced successfully"
            else
              echo "Error: S3 bucket $S3_BUCKET_NAME does not exist. Creating it now..."
              aws s3 mb "s3://$S3_BUCKET_NAME" --region ${{ env.AWS_REGION }}
              
              # Configure bucket policy for public read access
              aws s3api put-bucket-policy \
                --bucket $S3_BUCKET_NAME \
                --policy '{
                  "Version": "2012-10-17",
                  "Statement": [
                    {
                      "Effect": "Allow",
                      "Principal": "*",
                      "Action": "s3:GetObject",
                      "Resource": "arn:aws:s3:::'$S3_BUCKET_NAME'/*"
                    }
                  ]
                }'
              
              # Enable static website hosting
              aws s3 website "s3://$S3_BUCKET_NAME" \
                --index-document index.html \
                --error-document index.html
                
              echo "Bucket created, now syncing files..."
              aws s3 sync apps/event-monitor/dist s3://$S3_BUCKET_NAME --delete
              aws s3 cp apps/event-monitor/dist/index.html s3://$S3_BUCKET_NAME/index.html --cache-control "no-cache,no-store,must-revalidate"
              echo "Files synced successfully"
            fi

  deploy-infrastructure:
    needs: build-backend
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
      - uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download deployment package
        uses: actions/download-artifact@v4
        with:
          name: deployment-package
          path: .

      - name: Upload to S3
        run: |
          aws s3api head-bucket --bucket "${TERRAFORM_STATE_BUCKET}" 2>/dev/null || \
            aws s3 mb "s3://${TERRAFORM_STATE_BUCKET}" --region ${AWS_REGION}
          
          aws s3 cp ${{ env.ZIP_FILE_NAME }} \
            "s3://${TERRAFORM_STATE_BUCKET}/${{ env.ZIP_FILE_NAME }}" \
            --sse AES256

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.5.0"
          terraform_wrapper: false

      - name: Prepare Terraform Directory
        run: |
          echo "Creating Terraform working directory..."
          mkdir -p ${{ env.TERRAFORM_WORKING_DIR }}
          
          echo "Generating SSH key..."
          cd ${{ env.TERRAFORM_WORKING_DIR }}
          ssh-keygen -t rsa -b 4096 -f ssh_key -N "" -C "ec2-user"
          
          echo "Creating variables file..."
          cat > variables.tf << 'EOF'
          variable "aws_region" {
            type = string
          }
          variable "project_name" {
            type = string
          }
          variable "environment" {
            type = string
          }
          variable "instance_type" {
            type = string
          }
          variable "app_port" {
            type = number
          }
          variable "frontend_bucket_name" {
            type = string
          }
          variable "vpc_cidr" {
            type = string
            default = "10.0.0.0/16"
          }
          variable "public_subnet_cidrs" {
            type = list(string)
            default = ["10.0.101.0/24", "10.0.102.0/24"]
          }
          variable "private_subnet_cidrs" {
            type = list(string)
            default = ["10.0.1.0/24", "10.0.2.0/24"]
          }
          variable "availability_zones" {
            type = list(string)
          }
          variable "tags" {
            type = map(string)
            default = {
              Environment = "production"
              Terraform   = "true"
            }
          }
          EOF

      - name: Cleanup existing resources
        run: |
          echo "Cleaning up existing resources..."
          aws ec2 delete-key-pair --key-name eventdrivensystem-key || true
          
          ROLE_NAME="eventdrivensystem-ec2-role"
          INSTANCE_PROFILE="eventdrivensystem-ec2-profile"
          
          echo "Checking for existing IAM resources..."
          
          # Check and cleanup instance profile
          if aws iam get-instance-profile --instance-profile-name $INSTANCE_PROFILE 2>/dev/null; then
            echo "Removing role from instance profile..."
            aws iam remove-role-from-instance-profile \
              --instance-profile-name $INSTANCE_PROFILE \
              --role-name $ROLE_NAME || true
              
            echo "Deleting instance profile..."
            aws iam delete-instance-profile --instance-profile-name $INSTANCE_PROFILE || true
          fi
          
          # Check and cleanup IAM role
          if aws iam get-role --role-name $ROLE_NAME 2>/dev/null; then
            echo "Detaching policies from role..."
            for policy in $(aws iam list-attached-role-policies --role-name $ROLE_NAME --query 'AttachedPolicies[*].PolicyArn' --output text); do
              echo "Detaching policy: $policy"
              aws iam detach-role-policy --role-name $ROLE_NAME --policy-arn "$policy" || true
            done
            
            echo "Deleting inline policies..."
            for policy in $(aws iam list-role-policies --role-name $ROLE_NAME --query 'PolicyNames[*]' --output text); do
              echo "Deleting inline policy: $policy"
              aws iam delete-role-policy --role-name $ROLE_NAME --policy-name "$policy" || true
            done
            
            echo "Deleting IAM role..."
            aws iam delete-role --role-name $ROLE_NAME || true
          fi
          
          echo "Waiting for IAM resources to be fully deleted..."
          sleep 15
          
          echo "Cleanup completed"

      - name: Initialize Terraform
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: |
          echo "Verifying Terraform installation..."
          terraform version
          
          echo "Initializing Terraform..."
          terraform init \
            -backend=true \
            -backend-config="bucket=${{ env.TERRAFORM_STATE_BUCKET }}" \
            -backend-config="key=terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Import existing resources if they exist
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: |
          # Try to import existing role if cleanup failed
          if aws iam get-role --role-name eventdrivensystem-ec2-role 2>/dev/null; then
            echo "Importing existing IAM role..."
            terraform import aws_iam_role.ec2_role eventdrivensystem-ec2-role || true
          fi

      - name: Apply Terraform Configuration
        working-directory: ${{ env.TERRAFORM_WORKING_DIR }}
        run: |
          terraform apply -auto-approve \
            -var="aws_region=${{ env.AWS_REGION }}" \
            -var="project_name=eventdrivensystem" \
            -var="environment=production" \
            -var="instance_type=${{ env.INSTANCE_TYPE }}" \
            -var="app_port=${{ env.APP_PORT }}" \
            -var="frontend_bucket_name=${{ env.S3_BUCKET_NAME }}" \
            -var="availability_zones=[\"${{ env.AWS_REGION }}a\",\"${{ env.AWS_REGION }}b\"]"

      - name: Deploy application
        run: |
          # Get EC2 instance IP
          EC2_IP=$(terraform output -state=${{ env.TERRAFORM_WORKING_DIR }}/terraform.tfstate -raw instance_public_ip)
          
          echo "EC2 Instance IP: ${EC2_IP}"
          
          echo "Waiting for instance to be ready..."
          sleep 60
          
          echo "Running setup script..."
          ssh -o StrictHostKeyChecking=no \
            -i ${{ env.TERRAFORM_WORKING_DIR }}/ssh_key \
            ${EC2_USER}@${EC2_IP} 'bash -s' < scripts/setup.sh
          
          echo "Copying deployment package..."
          scp -o StrictHostKeyChecking=no \
            -i ${{ env.TERRAFORM_WORKING_DIR }}/ssh_key \
            ${{ env.ZIP_FILE_NAME }} ${EC2_USER}@${EC2_IP}:/tmp/
          
          echo "Running deployment script..."
          scp -o StrictHostKeyChecking=no \
            -i ${{ env.TERRAFORM_WORKING_DIR }}/ssh_key \
            scripts/deploy.sh ${EC2_USER}@${EC2_IP}:/tmp/
          
          ssh -o StrictHostKeyChecking=no \
            -i ${{ env.TERRAFORM_WORKING_DIR }}/ssh_key \
            ${EC2_USER}@${EC2_IP} 'chmod +x /tmp/deploy.sh && /tmp/deploy.sh'

      - name: Verify deployment
        run: |
          # Get EC2 instance IP
          EC2_IP=$(terraform output -state=${{ env.TERRAFORM_WORKING_DIR }}/terraform.tfstate -raw instance_public_ip)
          
          echo "Waiting for application to be ready..."
          sleep 30
          
          # Try multiple times to connect
          MAX_RETRIES=5
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            if curl -s -f "http://${EC2_IP}"; then
              echo "Application is responding successfully!"
              exit 0
            else
              echo "Attempt $((RETRY_COUNT + 1)) failed. Waiting before retry..."
              sleep 10
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done
          
          echo "Application is not responding after $MAX_RETRIES attempts"
          
          # Get logs from the instance for debugging
          echo "Fetching logs from instance..."
          ssh -o StrictHostKeyChecking=no \
            -i ${{ env.TERRAFORM_WORKING_DIR }}/ssh_key \
            ${EC2_USER}@${EC2_IP} '
              echo "PM2 Status:"
              sudo env PATH=$PATH:/usr/local/bin:/usr/bin pm2 list
              echo "PM2 Logs:"
              sudo env PATH=$PATH:/usr/local/bin:/usr/bin pm2 logs app --lines 100
              echo "Nginx Status:"
              sudo systemctl status nginx
              echo "Nginx Logs:"
              sudo cat /var/log/nginx/error.log
            '
          
          exit 1